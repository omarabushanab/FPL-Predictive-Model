// Players with two positions (one is DEF) -> find fixtures where recorded total_points
// don't match what they'd score if they were a defender (i.e. likely mistaken DEF assignments).
// Uses scoring rules from the Milestone PDF. :contentReference[oaicite:1]{index=1}

MATCH (p:Player)-[:PLAYS_AS]->(pos)
WITH p, collect(pos.name) AS positions
WHERE size(positions) > 1 AND 'DEF' IN positions

// get all fixtures this player played in
MATCH (p)-[r:PLAYED_IN]->(f:Fixture)
WITH p, r, f,

  // components according to rules in the PDF:
  // goals by DEF = 6 pts each, assists = 3, play time: <60 -> 1, >=60 -> 2
  // clean sheet for DEF: +4 only if minutes > 60 and clean_sheets flag
  // goals conceded: -1 for every 2 conceded
  // penalty miss -2, own goal -2, yellow -1, red -3
  (r.goals_scored * 6)                                  AS goals_pts,
  (r.assists * 3)                                       AS assists_pts,
  CASE WHEN r.minutes >= 60 THEN 2
       WHEN r.minutes > 0  THEN 1
       ELSE 0 END                                         AS playtime_pts,
  CASE WHEN r.minutes > 60 AND coalesce(r.clean_sheets,0) >= 1 THEN 4 ELSE 0 END AS cs_pts,
  (toInteger(coalesce(r.goals_conceded,0) / 2) * -1)    AS gc_pts,
  (coalesce(r.penalties_missed,0) * -2)                 AS pm_pts,
  (coalesce(r.own_goals,0) * -2)                        AS og_pts,
  (coalesce(r.yellow_cards,0) * -1)                     AS yc_pts,
  (coalesce(r.red_cards,0) * -3)                        AS rc_pts,
  r.total_points                                        AS recorded_points

// compute defender expected score for this fixture
WITH p, f, r,
     (goals_pts + assists_pts + playtime_pts + cs_pts + gc_pts + pm_pts + og_pts + yc_pts + rc_pts)
     AS def_score, recorded_points

// mark whether defender-score equals recorded points
WITH p, f, r, def_score, recorded_points, (def_score = recorded_points) AS matches_def

// keep only fixtures that DO NOT match defender scoring (i.e. likely incorrect defender assignment)
WHERE NOT matches_def

// aggregate per player: number of incorrect fixtures and details
WITH p,
     count(*) AS not_def_fixtures,
     collect({
       def_score: toFloat(def_score),
       season: f.season,
       fixture_number: f.fixture_number,
       matches_def: matches_def,
       total_points: recorded_points
     }) AS fixture_details

// find total fixtures the player played (to return total_fixtures)
MATCH (p)-[r2:PLAYED_IN]->(f2:Fixture)
WITH p, not_def_fixtures, fixture_details, count(r2) AS total_fixtures

RETURN p.player_name AS player,
       not_def_fixtures,
       total_fixtures,
       fixture_details
ORDER BY not_def_fixtures DESC, player;
